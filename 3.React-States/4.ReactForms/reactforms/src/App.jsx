import { useState } from "react";
import "./App.css";

//In regular html php forms, we would be gathering the data from the input fields and sending it to the server after the submit button is clicked
//In React based apps, we will update state variables every time the input fields are modified.
//We are going to use Controlled Components whose value we are going to keep track and update the state.

function App() {
	//We initialize the state of the form's data which will be an object and the keys are going to correspond to the values of each input field
	const [formData, setFormData] = useState({
		firstName: "",
		lastName: "",
		email: "",
		comments: "",
		//Checkboxes will need a boolean value
		isFriendly: true,
		//Radio buttons are a mix of checkboxes and text inputs. Every time one of the radios is clicked, the function will run and set the employment key to the according value of that radio
		employment: "",
		favColor: "",
	});

	//We create a function listening to the change of the inputs. This event listener function will ALWAYS receive the event object which is a massive object generated by the browser containing every single piece of the data of whatever is going on in the input field
	function handleChange(event) {
		//A best practice is destructuring the key values in variables so that we can work with slimmer code in the setter function
		const { name, value, type, checked } = event.target;
		//Our setter function is going to return an object of course
		setFormData((prevFormData) => {
			return {
				...prevFormData,
				//We can extrapolate the actual value of the string being input in the text field by using dot notation on the event object
				//To target the specific key dynamically we are going to use the name attribute we have given in the html input tag as the key and set its value to the value being input in the field. Notice that we have to use ES6 computed properties (surrounding our keys in square brackets) to avoid syntax errors since they are technically string variables
				//Since we are working with multiple types of inputs, we can make a ternary to check if the inputs are checkbox to take on the checked value or the regular string values
				[name]: type === "checkbox" ? checked : value,
			};
		});
	}

	function handleSubmit(event) {
		//We don't want our values to be reset if the page is refreshed but unfortunately html expects us to send the data all in one go via php so upon clicking the submit button it will do it. We can avoid that by using the preventDefault() method
		event.preventDefault();
		//Since we've been tracking via state every value changed on keystroke/click, we can just imagine a "sendToApi" function that will take just the formData object since it's updated on every change of state
		console.log(formData);
	}

	return (
		<div className="App">
			<form onSubmit={handleSubmit}>
				<input
					type="text"
					placeholder="First Name"
					//The onChange attribute will link to the handleChange function
					onChange={handleChange}
					//To target each of our inputs we are going to also give them a name attribute MATCHING the key of the state formData object
					name="firstName"
					//A best practice when using inputs is Controlling Components
					//The React infrastructure might complain if we don't put it in the driver's seat when setting up forms.
					//That is why we need to set up Controlled Components meaning the state will not be dependant on the value of the input but the other way around
					//We are going to specify that the value of the input box needs to follow the keys of the state object
					//Every change will rerun the handleChange function which will update the correct piece of state then rerendering the form with the desired input value corresponding to the state value
					value={formData.firstName}
				/>
				<input
					type="text"
					placeholder="Last Name"
					onChange={handleChange}
					name="lastName"
					value={formData.lastName}
				/>
				<input
					type="text"
					placeholder="E-mail"
					onChange={handleChange}
					name="email"
					value={formData.email}
				/>
				{/* The textarea tag works more or less like the text field in JSX and it's self closing */}
				<textarea
					placeholder="Your Comment..."
					onChange={handleChange}
					name="comments"
					value={formData.comments}
				/>
				{/* For checkboxes we are going to give an id attribute that has to correspond to the htmlFor attribute in the label to link them together*/}
				<input
					type="checkbox"
					id="isFriendly"
					checked={formData.isFriendly}
					onChange={handleChange}
					name="isFriendly"
				/>
				<label htmlFor="isFriendly">Are you friendly?</label>
				<fieldset>
					<legend>Current employment status</legend>

					<input
						type="radio"
						id="unemployed"
						//Remember that the name has to correspond to the key, so it will be the same for all 3 radio inputs
						name="employment"
						value="unemployed"
						onChange={handleChange}
						//Since the employment key doesn't take a boolean value checked will not work by simply link it to the formData key, we can make it a boolean by using a condition so that it is now a Controlled Component
						checked={formData.employment === "unemployed"}
					/>
					<label htmlFor="unemployed">Unemployed</label>
					<br />

					<input
						type="radio"
						id="part-time"
						name="employment"
						value="part-time"
						onChange={handleChange}
						checked={formData.employment === "part-time"}
					/>
					<label htmlFor="part-time">Part-time</label>
					<br />

					<input
						type="radio"
						id="full-time"
						name="employment"
						value="full-time"
						onChange={handleChange}
						checked={formData.employment === "full-time"}
					/>
					<label htmlFor="full-time">Full-time</label>
					<br />
				</fieldset>
				<br />

				{/* Select inputs are pretty straight forward we will just need to link the key of state to the value of the options */}
				<label htmlFor="favColor">What is your favorite color?</label>
				<br />
				<select
					id="favColor"
					value={formData.favColor}
					onChange={handleChange}
					name="favColor"
				>
					{/* A best practice is adding a default empty string value as the default value*/}
					<option value="">--- Choose ---</option>
					<option value="red">Red</option>
					<option value="orange">Orange</option>
					<option value="yellow">Yellow</option>
					<option value="green">Green</option>
					<option value="blue">Blue</option>
					<option value="indigo">Indigo</option>
					<option value="violet">Violet</option>
				</select>
				<br />
				<br />
				{/* In HTML5 a button inside of a form will default to a submit button and trigger the onSubmit event */}
				<button type="submit">Submit</button>
			</form>
		</div>
	);
}

export default App;
